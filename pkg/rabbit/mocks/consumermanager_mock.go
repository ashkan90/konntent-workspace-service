// Code generated by MockGen. DO NOT EDIT.
// Source: ./pkg/rabbit/consumermanager.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	amqp "github.com/streadway/amqp"
)

// MockConsumerGroupHandler is a mock of ConsumerGroupHandler interface.
type MockConsumerGroupHandler struct {
	ctrl     *gomock.Controller
	recorder *MockConsumerGroupHandlerMockRecorder
}

// MockConsumerGroupHandlerMockRecorder is the mock recorder for MockConsumerGroupHandler.
type MockConsumerGroupHandlerMockRecorder struct {
	mock *MockConsumerGroupHandler
}

// NewMockConsumerGroupHandler creates a new mock instance.
func NewMockConsumerGroupHandler(ctrl *gomock.Controller) *MockConsumerGroupHandler {
	mock := &MockConsumerGroupHandler{ctrl: ctrl}
	mock.recorder = &MockConsumerGroupHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsumerGroupHandler) EXPECT() *MockConsumerGroupHandlerMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockConsumerGroupHandler) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockConsumerGroupHandlerMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockConsumerGroupHandler)(nil).Close))
}

// ConsumeClaim mocks base method.
func (m *MockConsumerGroupHandler) ConsumeClaim(ctx context.Context, queue <-chan amqp.Delivery) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConsumeClaim", ctx, queue)
	ret0, _ := ret[0].(error)
	return ret0
}

// ConsumeClaim indicates an expected call of ConsumeClaim.
func (mr *MockConsumerGroupHandlerMockRecorder) ConsumeClaim(ctx, queue interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConsumeClaim", reflect.TypeOf((*MockConsumerGroupHandler)(nil).ConsumeClaim), ctx, queue)
}

// Status mocks base method.
func (m *MockConsumerGroupHandler) Status() chan bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(chan bool)
	return ret0
}

// Status indicates an expected call of Status.
func (mr *MockConsumerGroupHandlerMockRecorder) Status() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockConsumerGroupHandler)(nil).Status))
}

// MockCustomHandler is a mock of CustomHandler interface.
type MockCustomHandler struct {
	ctrl     *gomock.Controller
	recorder *MockCustomHandlerMockRecorder
}

// MockCustomHandlerMockRecorder is the mock recorder for MockCustomHandler.
type MockCustomHandlerMockRecorder struct {
	mock *MockCustomHandler
}

// NewMockCustomHandler creates a new mock instance.
func NewMockCustomHandler(ctrl *gomock.Controller) *MockCustomHandler {
	mock := &MockCustomHandler{ctrl: ctrl}
	mock.recorder = &MockCustomHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCustomHandler) EXPECT() *MockCustomHandlerMockRecorder {
	return m.recorder
}

// Do mocks base method.
func (m *MockCustomHandler) Do(ctx context.Context, delivery amqp.Delivery) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Do", ctx, delivery)
	ret0, _ := ret[0].(error)
	return ret0
}

// Do indicates an expected call of Do.
func (mr *MockCustomHandlerMockRecorder) Do(ctx, delivery interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockCustomHandler)(nil).Do), ctx, delivery)
}

// MockConsumerManager is a mock of ConsumerManager interface.
type MockConsumerManager struct {
	ctrl     *gomock.Controller
	recorder *MockConsumerManagerMockRecorder
}

// MockConsumerManagerMockRecorder is the mock recorder for MockConsumerManager.
type MockConsumerManagerMockRecorder struct {
	mock *MockConsumerManager
}

// NewMockConsumerManager creates a new mock instance.
func NewMockConsumerManager(ctrl *gomock.Controller) *MockConsumerManager {
	mock := &MockConsumerManager{ctrl: ctrl}
	mock.recorder = &MockConsumerManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsumerManager) EXPECT() *MockConsumerManagerMockRecorder {
	return m.recorder
}

// Process mocks base method.
func (m *MockConsumerManager) Process(ctx context.Context, delivery amqp.Delivery) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Process", ctx, delivery)
	ret0, _ := ret[0].(error)
	return ret0
}

// Process indicates an expected call of Process.
func (mr *MockConsumerManagerMockRecorder) Process(ctx, delivery interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Process", reflect.TypeOf((*MockConsumerManager)(nil).Process), ctx, delivery)
}
